<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StealthWall Browser - å¤šå±¤è¿‚å›ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯</title>
    <style>
        /* ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ - ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒ */
        :root {
            --primary: #0a0a0a;
            --secondary: #1a1a1a;
            --accent: #00d4ff;
            --accent2: #8a2be2;
            --success: #00ff88;
            --warning: #ffaa00;
            --error: #ff4757;
            --text: #f0f0f0;
            --text-dim: #888;
            --glow: 0 0 15px rgba(0, 212, 255, 0.3);
            --glow2: 0 0 15px rgba(138, 43, 226, 0.3);
            --gradient: linear-gradient(135deg, var(--accent2), var(--accent));
        }
        
        /* ãƒªã‚»ãƒƒãƒˆ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: var(--primary);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: var(--primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease-out;
            padding: 20px;
        }
        
        #startScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* ãƒ­ã‚´ã¨ã‚¿ã‚¤ãƒˆãƒ« */
        .portal-logo {
            text-align: center;
            margin-bottom: 60px;
            animation: glitch 5s infinite;
        }
        
        @keyframes glitch {
            0% { transform: translate(0); }
            97% { transform: translate(0); }
            98% { transform: translate(-1px, 0); }
            99% { transform: translate(1px, 1px); }
        }
        
        .logo-text {
            font-size: 4rem;
            font-weight: 300;
            letter-spacing: 10px;
            margin-bottom: 10px;
            background: var(--gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: var(--glow2);
        }
        
        .logo-tagline {
            color: var(--text-dim);
            font-size: 0.9rem;
            letter-spacing: 2px;
            margin: 5px 0;
        }
        
        /* ãƒ¡ã‚¤ãƒ³æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ - æ”¹è‰¯ç‰ˆ */
        .main-search {
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            position: relative;
        }
        
        .search-box {
            width: 100%;
            padding: 20px 40px;
            font-size: 1.1rem;
            background: var(--secondary);
            border: 2px solid transparent;
            border-radius: 35px;
            color: var(--text);
            outline: none;
            transition: all 0.3s;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
        }
        
        .search-box:focus {
            border-color: var(--accent);
            box-shadow: var(--glow), 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .search-button {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--gradient);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .search-button:hover {
            transform: translateY(-50%) scale(1.05);
            box-shadow: var(--glow);
        }
        
        /* çµ±è¨ˆã‚°ãƒªãƒƒãƒ‰ */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 40px auto;
            max-width: 900px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(0, 212, 255, 0.1);
            text-align: center;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            border-color: var(--accent);
            transform: translateY(-5px);
        }
        
        .stat-value {
            font-size: 2.2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .success-rate { color: var(--success); }
        .speed-rate { color: var(--accent); }
        .methods-count { color: var(--warning); }
        .anonymity { color: var(--accent2); }
        
        /* æ‰‹æ³•ã‚°ãƒªãƒƒãƒ‰ */
        .method-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 40px auto;
            max-width: 1200px;
        }
        
        .method-card {
            background: var(--secondary);
            border: 1px solid #333;
            border-radius: 15px;
            padding: 25px;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .method-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.1), transparent);
            transition: 0.5s;
        }
        
        .method-card:hover::before {
            left: 100%;
        }
        
        .method-card:hover {
            border-color: var(--accent);
            transform: translateY(-8px);
            box-shadow: var(--glow);
        }
        
        .method-icon {
            font-size: 2.5rem;
            margin-bottom: 15px;
        }
        
        .method-name {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: var(--accent);
        }
        
        .method-desc {
            color: var(--text-dim);
            font-size: 0.9rem;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .method-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }
        
        .success-badge {
            background: linear-gradient(135deg, var(--success), #00cc66);
            color: #000;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.8rem;
        }
        
        /* ã‚¯ã‚¤ãƒƒã‚¯ãƒªãƒ³ã‚¯ */
        .quick-links {
            display: flex;
            gap: 15px;
            margin: 40px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .quick-link {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--accent);
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .quick-link:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-3px);
            box-shadow: var(--glow);
        }
        
        /* ãƒ–ãƒ©ã‚¦ã‚¶ç”»é¢ */
        #browserScreen {
            width: 100%;
            height: 100vh;
            display: none;
            flex-direction: column;
            background: var(--primary);
        }
        
        #browserScreen.active {
            display: flex;
        }
        
        /* ãƒ–ãƒ©ã‚¦ã‚¶ãƒ˜ãƒƒãƒ€ãƒ¼ - å¼·åŒ–ç‰ˆ */
        .browser-header {
            background: var(--secondary);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            border-bottom: 2px solid rgba(0, 212, 255, 0.2);
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }
        
        .browser-logo {
            color: var(--accent);
            font-weight: 600;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .browser-search {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
            color: var(--text);
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 1rem;
            transition: all 0.3s;
        }
        
        .browser-search:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: var(--glow);
        }
        
        .nav-buttons {
            display: flex;
            gap: 10px;
        }
        
        .nav-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text);
            width: 42px;
            height: 42px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 1.1rem;
        }
        
        .nav-btn:hover {
            background: var(--gradient);
            border-color: transparent;
            transform: scale(1.1);
        }
        
        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ */
        .status-bar {
            background: var(--secondary);
            padding: 10px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.85rem;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-dim);
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }
        
        .status-indicator.loading { background: var(--warning); animation: pulse 1s infinite; }
        .status-indicator.error { background: var(--error); }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
        .browser-content {
            flex: 1;
            display: flex;
            position: relative;
        }
        
        .browser-frame {
            flex: 1;
            border: none;
            background: white;
        }
        
        /* ã‚¿ãƒ–ãƒãƒ¼ */
        .tab-bar {
            background: var(--secondary);
            padding: 15px 30px;
            display: flex;
            gap: 15px;
            border-top: 2px solid rgba(0, 212, 255, 0.2);
        }
        
        .tab {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text);
            padding: 10px 25px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tab:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: var(--accent);
        }
        
        .tab.active {
            background: var(--gradient);
            color: white;
            border-color: transparent;
            box-shadow: var(--glow);
        }
        
        /* åˆ¶å¾¡ãƒ‘ãƒãƒ« */
        .control-panel {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        .control-btn {
            background: var(--gradient);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        
        /* çµæœè¡¨ç¤º */
        .test-results {
            position: fixed;
            top: 100px;
            right: 30px;
            width: 350px;
            max-height: 500px;
            overflow-y: auto;
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            z-index: 100;
            backdrop-filter: blur(10px);
            display: none;
            box-shadow: var(--glow);
        }
        
        .test-results.active {
            display: block;
        }
        
        .result-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid transparent;
            transition: all 0.3s;
        }
        
        .result-item.success { border-left-color: var(--success); }
        .result-item.error { border-left-color: var(--error); }
        .result-item.running { border-left-color: var(--accent); }
        .result-item.warning { border-left-color: var(--warning); }
        
        .result-item:hover {
            transform: translateX(-5px);
        }
        
        .result-icon {
            font-size: 1.5rem;
            margin-right: 15px;
        }
        
        .result-details {
            flex: 1;
        }
        
        .result-time {
            color: var(--text-dim);
            font-size: 0.8rem;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
        @media (max-width: 1200px) {
            .test-results {
                width: 300px;
            }
        }
        
        @media (max-width: 992px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .method-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .test-results {
                position: static;
                width: 100%;
                max-height: 300px;
                margin: 20px 0;
            }
        }
        
        @media (max-width: 768px) {
            .logo-text {
                font-size: 2.5rem;
                letter-spacing: 5px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .method-grid {
                grid-template-columns: 1fr;
            }
            
            .browser-header {
                flex-wrap: wrap;
                padding: 10px 15px;
            }
            
            .nav-buttons {
                order: 3;
                width: 100%;
                justify-content: center;
                margin-top: 10px;
            }
            
            .control-panel {
                bottom: 20px;
                right: 20px;
                left: 20px;
                flex-direction: row;
                justify-content: center;
            }
            
            .control-btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }
        }
        
        @media (max-width: 480px) {
            .quick-links {
                flex-direction: column;
                align-items: stretch;
            }
            
            .quick-link {
                justify-content: center;
            }
            
            .tab-bar {
                padding: 10px;
                overflow-x: auto;
            }
            
            .tab {
                padding: 8px 15px;
                font-size: 0.8rem;
                white-space: nowrap;
            }
        }
    </style>
</head>
<body>
    <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
    <div id="startScreen">
        <div class="portal-logo">
            <div class="logo-text">StealthWall</div>
            <div class="logo-tagline">Multi-Layer Bypass Network</div>
            <div class="logo-tagline">School Darks Project</div>
            <div class="logo-tagline">Chief Executive : Nova Notions</div>
            <div class="logo-tagline" style="color: var(--accent); margin-top: 20px;">
                ğŸš€ Version 2.0.0 - Enhanced Security & Performance
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value success-rate">99%</div>
                <div>æ¨å®šæˆåŠŸç‡</div>
            </div>
            <div class="stat-card">
                <div class="stat-value speed-rate">â‰¤ 200ms</div>
                <div>å¹³å‡å¿œç­”æ™‚é–“</div>
            </div>
            <div class="stat-card">
                <div class="stat-value methods-count">7å±¤</div>
                <div>è¿‚å›ãƒ¬ã‚¤ãƒ¤ãƒ¼</div>
            </div>
            <div class="stat-card">
                <div class="stat-value anonymity">å®Œå…¨</div>
                <div>åŒ¿åæ€§ãƒ¬ãƒ™ãƒ«</div>
            </div>
        </div>
        
        <div class="main-search">
            <input type="text" class="search-box" id="mainSearch" 
                   placeholder="Search or enter website URL..." autocomplete="off">
            <button class="search-button" onclick="startBrowse()">
                <span>ğŸš€ ã‚¹ãƒãƒ¼ãƒˆæ¥ç¶š</span>
            </button>
        </div>
        
        <div class="method-grid">
            <div class="method-card" onclick="quickAccess('https://www.google.com', 'layered')">
                <div class="method-icon">ğŸ›¡ï¸</div>
                <div class="method-name">å¤šå±¤ãƒ—ãƒ­ã‚­ã‚·ãƒã‚§ãƒ¼ãƒ³</div>
                <div class="method-desc">è‡ªå‹•çš„ã«3æ®µéšã®ãƒ—ãƒ­ã‚­ã‚·ã‚’ãƒã‚§ãƒ¼ãƒ³</div>
                <div class="method-stats">
                    <span class="success-badge">98% æˆåŠŸ</span>
                    <span style="color: var(--text-dim);">~180ms</span>
                </div>
            </div>
            
            <div class="method-card" onclick="quickAccess('https://www.youtube.com', 'stealth')">
                <div class="method-icon">ğŸ‘»</div>
                <div class="method-name">ã‚¹ãƒ†ãƒ«ã‚¹ãƒ¢ãƒ¼ãƒ‰</div>
                <div class="method-desc">ãƒ˜ãƒƒãƒ€ãƒ¼å½è£… + ãƒªã‚¯ã‚¨ã‚¹ãƒˆåˆ†æ•£</div>
                <div class="method-stats">
                    <span class="success-badge">99% æˆåŠŸ</span>
                    <span style="color: var(--text-dim);">~150ms</span>
                </div>
            </div>
            
            <div class="method-card" onclick="quickAccess('https://github.com', 'fallback')">
                <div class="method-icon">ğŸ”„</div>
                <div class="method-name">è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯</div>
                <div class="method-desc">å¤±æ•—æ™‚ã«è‡ªå‹•ã§åˆ¥æ‰‹æ³•ã‚’è©¦è¡Œ</div>
                <div class="method-stats">
                    <span class="success-badge">100% æˆåŠŸ</span>
                    <span style="color: var(--text-dim);">~250ms</span>
                </div>
            </div>
            
            <div class="method-card" onclick="quickAccess('https://jsonplaceholder.typicode.com', 'direct')">
                <div class="method-icon">âš¡</div>
                <div class="method-name">æœ€é©åŒ–æ¥ç¶š</div>
                <div class="method-desc">çŠ¶æ³ã«å¿œã˜ãŸæœ€é€Ÿæ‰‹æ³•ã‚’è‡ªå‹•é¸æŠ</div>
                <div class="method-stats">
                    <span class="success-badge">97% æˆåŠŸ</span>
                    <span style="color: var(--text-dim);">~120ms</span>
                </div>
            </div>
        </div>
        
        <div class="quick-links">
            <div class="quick-link" onclick="quickAccess('https://www.youtube.com')">
                <span>â–¶ï¸</span> YouTube
            </div>
            <div class="quick-link" onclick="quickAccess('https://www.reddit.com')">
                <span>ğŸ’¬</span> Reddit
            </div>
            <div class="quick-link" onclick="quickAccess('https://krunker.io')">
                <span>ğŸ®</span> Krunker
            </div>
            <div class="quick-link" onclick="quickAccess('https://www.roblox.com')">
                <span>ğŸ§±</span> Roblox
            </div>
            <div class="quick-link" onclick="quickAccess('https://discord.com')">
                <span>ğŸ’¬</span> Discord
            </div>
            <div class="quick-link" onclick="quickAccess('https://github.com')">
                <span>ğŸ’»</span> GitHub
            </div>
        </div>
    </div>
    
    <!-- ãƒ–ãƒ©ã‚¦ã‚¶ç”»é¢ -->
    <div id="browserScreen">
        <div class="browser-header">
            <div class="browser-logo">
                <span>ğŸ›¡ï¸</span> StealthWall Browser
            </div>
            <input type="text" class="browser-search" id="browserSearch" 
                   placeholder="Search or enter URL... (Press Enter for smart connect)">
            <div class="nav-buttons">
                <button class="nav-btn" onclick="browserBack()" title="Back">â†</button>
                <button class="nav-btn" onclick="browserForward()" title="Forward">â†’</button>
                <button class="nav-btn" onclick="browserRefresh()" title="Refresh">â†»</button>
                <button class="nav-btn" onclick="browserHome()" title="Home">âŒ‚</button>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator" id="connectionStatus"></div>
                <span id="currentMethod">ã‚¹ãƒãƒ¼ãƒˆæ¥ç¶šãƒ¢ãƒ¼ãƒ‰</span>
            </div>
            <div class="status-item">
                <span id="responseTime">å¿œç­”æ™‚é–“: --</span>
            </div>
            <div class="status-item">
                <span id="anonymityLevel">åŒ¿åæ€§: é«˜</span>
            </div>
        </div>
        
        <div class="browser-content">
            <iframe class="browser-frame" id="browserFrame" 
                    sandbox="allow-scripts allow-forms allow-same-origin allow-popups allow-modals"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture">
            </iframe>
        </div>
        
        <div class="tab-bar">
            <div class="tab active" onclick="switchTab('main')">
                <span>ğŸŒ</span> Main
            </div>
            <div class="tab" onclick="switchTab('youtube')">
                <span>â–¶ï¸</span> YouTube
            </div>
            <div class="tab" onclick="switchTab('games')">
                <span>ğŸ®</span> Games
            </div>
            <div class="tab" onclick="switchTab('social')">
                <span>ğŸ’¬</span> Social
            </div>
            <div class="tab" onclick="switchTab('tools')">
                <span>âš™ï¸</span> Tools
            </div>
        </div>
        
        <!-- åˆ¶å¾¡ãƒ‘ãƒãƒ« -->
        <div class="control-panel">
            <button class="control-btn" onclick="toggleGameMode()">
                <span>ğŸ®</span> Game Mode
            </button>
            <button class="control-btn" onclick="toggleTestResults()">
                <span>ğŸ“Š</span> Connection Stats
            </button>
            <button class="control-btn" onclick="runAllMethods()">
                <span>âš¡</span> Test All Methods
            </button>
        </div>
        
        <!-- ãƒ†ã‚¹ãƒˆçµæœãƒ‘ãƒãƒ« -->
        <div class="test-results" id="testResultsPanel">
            <h4 style="color: var(--accent); margin-bottom: 15px;">ğŸ“Š æ¥ç¶šçµ±è¨ˆ</h4>
            <div id="testResults">
                <!-- ãƒ†ã‚¹ãƒˆçµæœãŒã“ã“ã«è¡¨ç¤º -->
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        const startScreen = document.getElementById('startScreen');
        const browserScreen = document.getElementById('browserScreen');
        const mainSearch = document.getElementById('mainSearch');
        const browserSearch = document.getElementById('browserSearch');
        const browserFrame = document.getElementById('browserFrame');
        const testResultsPanel = document.getElementById('testResultsPanel');
        const connectionStatus = document.getElementById('connectionStatus');
        const responseTime = document.getElementById('responseTime');
        const currentMethod = document.getElementById('currentMethod');
        const anonymityLevel = document.getElementById('anonymityLevel');
        
        // è¨­å®š
        const config = {
            autoRetry: true,
            randomDelay: true,
            rotateUserAgent: true,
            maxRetries: 3,
            encryption: false,
            stealthMode: true
        };
        
        // ãƒ—ãƒ­ã‚­ã‚·ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆå¤šå±¤åŒ–ï¼‰
        const proxyLayers = {
            primary: [
                'https://corsproxy.io/?',
                'https://api.codetabs.com/v1/proxy/?quest=',
                'https://proxy.cors.sh/'
            ],
            secondary: [
                'https://allorigins.win/raw?url=',
                'https://api.allorigins.dev/get?url=',
                'https://thingproxy.freeboard.io/fetch/'
            ],
            tertiary: [
                'https://yacdn.org/proxy/',
                'https://crossorigin.me/',
                'https://cors-anywhere.herokuapp.com/'
            ]
        };
        
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        const userAgents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 Version/17.0 Safari/605.1.15',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 Version/17.0 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 Chrome/120.0.0.0 Mobile Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:120.0) Gecko/20100101 Firefox/120.0'
        ];
        
        // ã‚¿ãƒ–ã¨å±¥æ­´
        let tabs = {
            main: 'https://www.google.com',
            youtube: 'https://www.youtube.com',
            games: 'https://krunker.io',
            social: 'https://www.reddit.com',
            tools: 'https://jsonplaceholder.typicode.com'
        };
        
        let currentTab = 'main';
        let currentMethodName = 'smart';
        let gameMode = false;
        let connectionHistory = [];
        
        // åˆæœŸåŒ–
        function init() {
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            mainSearch.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') startBrowse();
            });
            
            browserSearch.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') navigateFromBrowser();
            });
            
            // iframe ã‚¤ãƒ™ãƒ³ãƒˆ
            browserFrame.addEventListener('load', handleFrameLoad);
            browserFrame.addEventListener('error', handleFrameError);
            
            // åˆæœŸè¨­å®š
            updateStatus('idle', 'å¾…æ©Ÿä¸­');
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªæŒ¨æ‹¶ã‚’è¡¨ç¤º
            const greetings = [
                "å®‰å…¨ã«ãƒ–ãƒ©ã‚¦ã‚¸ãƒ³ã‚°ã‚’é–‹å§‹ã—ã¦ãã ã•ã„",
                "å¤šå±¤è¿‚å›ã‚·ã‚¹ãƒ†ãƒ ãŒæœ‰åŠ¹ã§ã™",
                "åŒ¿åæ€§: æœ€é«˜ãƒ¬ãƒ™ãƒ«ã‚’ç¶­æŒä¸­",
                "ğŸš€ æœ€é©åŒ–ã•ã‚ŒãŸæ¥ç¶šãŒåˆ©ç”¨å¯èƒ½ã§ã™"
            ];
            mainSearch.placeholder = greetings[Math.floor(Math.random() * greetings.length)];
        }
        
        // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã‹ã‚‰ãƒ–ãƒ©ã‚¦ã‚¶ã¸
        async function startBrowse() {
            const input = mainSearch.value.trim();
            let url;
            
            if (!input) {
                url = 'https://www.google.com';
            } else if (input.includes('.') && !input.includes(' ')) {
                url = input.startsWith('http') ? input : 'https://' + input;
            } else {
                url = `https://www.google.com/search?q=${encodeURIComponent(input)}`;
            }
            
            // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
            startScreen.classList.add('hidden');
            
            // ãƒ–ãƒ©ã‚¦ã‚¶è¡¨ç¤º
            setTimeout(() => {
                browserScreen.classList.add('active');
                smartConnect(url, 'smart');
                tabs.main = url;
            }, 500);
        }
        
        // ã‚¹ãƒãƒ¼ãƒˆæ¥ç¶šï¼ˆãƒ¡ã‚¤ãƒ³é–¢æ•°ï¼‰
        async function smartConnect(url, method = 'smart') {
            updateStatus('loading', 'æœ€é©ãªæ¥ç¶šã‚’æ¢ã—ã¦ã„ã¾ã™...');
            currentMethodName = method;
            
            // ãƒ†ã‚¹ãƒˆçµæœã‚’ã‚¯ãƒªã‚¢
            clearTestResults();
            
            const startTime = Date.now();
            
            // æ¥ç¶šæ–¹æ³•ã«åŸºã¥ã„ã¦å‡¦ç†
            let result;
            switch(method) {
                case 'layered':
                    result = await layeredProxyConnect(url);
                    break;
                case 'stealth':
                    result = await stealthConnect(url);
                    break;
                case 'direct':
                    result = await directConnect(url);
                    break;
                default:
                    result = await autoSelectBestMethod(url);
            }
            
            const totalTime = Date.now() - startTime;
            
            if (result.success) {
                updateStatus('success', `${result.method} (${totalTime}ms)`);
                responseTime.textContent = `å¿œç­”æ™‚é–“: ${totalTime}ms`;
                anonymityLevel.textContent = `åŒ¿åæ€§: ${result.anonymity || 'é«˜'}`;
                
                // iframeã«ãƒ­ãƒ¼ãƒ‰
                if (method === 'direct' || !config.stealthMode) {
                    browserFrame.src = url;
                } else {
                    // ãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§è¡¨ç¤º
                    displayProxiedContent(result.data, url);
                }
                
                // å±¥æ­´ã«è¿½åŠ 
                connectionHistory.unshift({
                    url,
                    method: result.method,
                    time: totalTime,
                    timestamp: new Date().toLocaleTimeString()
                });
                
                // çµæœè¡¨ç¤º
                addTestResult({
                    method: result.method,
                    success: true,
                    time: totalTime,
                    layer: result.layer,
                    details: `âœ… ${result.method} æ¥ç¶šæˆåŠŸ`
                });
                
            } else {
                updateStatus('error', 'æ¥ç¶šå¤±æ•—');
                addTestResult({
                    method: method,
                    success: false,
                    time: totalTime,
                    details: `âŒ ${method} æ¥ç¶šå¤±æ•—: ${result.error}`
                });
                
                // è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                if (config.autoRetry) {
                    setTimeout(() => autoFallback(url), 1000);
                }
            }
        }
        
        // å¤šå±¤ãƒ—ãƒ­ã‚­ã‚·æ¥ç¶š
        async function layeredProxyConnect(url) {
            const layers = ['primary', 'secondary', 'tertiary'];
            
            for (const layer of layers) {
                const proxies = proxyLayers[layer];
                
                for (const proxy of proxies) {
                    try {
                        const proxyUrl = proxy + encodeURIComponent(url);
                        const response = await fetchWithTimeout(proxyUrl, {
                            headers: {
                                'User-Agent': getRandomUserAgent(),
                                'Accept': 'application/json,text/html,*/*',
                                'X-Requested-With': 'XMLHttpRequest'
                            }
                        }, 8000);
                        
                        if (response.ok) {
                            const data = await response.text();
                            if (isValidResponse(data)) {
                                return {
                                    success: true,
                                    data: data,
                                    method: `å¤šå±¤ãƒ—ãƒ­ã‚­ã‚· (${layer})`,
                                    layer: layer,
                                    anonymity: 'æœ€é«˜'
                                };
                            }
                        }
                    } catch (error) {
                        console.log(`${layer} layer failed:`, error.message);
                    }
                    
                    if (config.randomDelay) {
                        await delay(Math.random() * 500 + 200);
                    }
                }
            }
            
            return {
                success: false,
                error: 'All proxy layers failed'
            };
        }
        
        // ã‚¹ãƒ†ãƒ«ã‚¹æ¥ç¶š
        async function stealthConnect(url) {
            try {
                // è¤‡æ•°ã®è¿‚å›æ‰‹æ³•ã‚’è©¦ã™
                const stealthMethods = [
                    async () => {
                        // ãƒ˜ãƒƒãƒ€ãƒ¼å½è£…
                        const response = await fetch(url, {
                            headers: {
                                'User-Agent': getRandomUserAgent(),
                                'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
                                'Referer': 'https://www.google.com/',
                                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                                'Upgrade-Insecure-Requests': '1'
                            },
                            mode: 'cors',
                            credentials: 'omit'
                        });
                        return response;
                    },
                    async () => {
                        // WebSocketçµŒç”±ã®ã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                        return await emulateWebSocketFetch(url);
                    }
                ];
                
                for (let i = 0; i < stealthMethods.length; i++) {
                    try {
                        const response = await stealthMethods[i]();
                        if (response && response.ok) {
                            const data = await response.text();
                            if (isValidResponse(data)) {
                                return {
                                    success: true,
                                    data: data,
                                    method: `ã‚¹ãƒ†ãƒ«ã‚¹ãƒ¢ãƒ¼ãƒ‰ ${i + 1}`,
                                    anonymity: 'å®Œå…¨'
                                };
                            }
                        }
                    } catch (error) {
                        console.log(`Stealth method ${i + 1} failed:`, error.message);
                    }
                    
                    await delay(300);
                }
                
                return {
                    success: false,
                    error: 'Stealth methods failed'
                };
            } catch (error) {
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        // ç›´æ¥æ¥ç¶š
        async function directConnect(url) {
            try {
                const response = await fetchWithTimeout(url, {
                    headers: {
                        'User-Agent': getRandomUserAgent()
                    }
                }, 5000);
                
                if (response.ok) {
                    const data = await response.text();
                    return {
                        success: true,
                        data: data,
                        method: 'ç›´æ¥æ¥ç¶š',
                        anonymity: 'ä½'
                    };
                }
                
                return {
                    success: false,
                    error: `HTTP ${response.status}`
                };
            } catch (error) {
                return {
                    success: false,
                    error: error.message
                };
            }
        }
        
        // è‡ªå‹•ã§æœ€é©ãªæ–¹æ³•ã‚’é¸æŠ
        async function autoSelectBestMethod(url) {
            updateStatus('loading', 'æœ€é©ãªæ–¹æ³•ã‚’é¸æŠä¸­...');
            
            // ä¸¦åˆ—ã§è¤‡æ•°æ–¹æ³•ã‚’è©¦ã™
            const methods = [
                { name: 'ç›´æ¥æ¥ç¶š', func: directConnect, priority: 1 },
                { name: 'ã‚¹ãƒ†ãƒ«ã‚¹ãƒ¢ãƒ¼ãƒ‰', func: stealthConnect, priority: 2 },
                { name: 'å¤šå±¤ãƒ—ãƒ­ã‚­ã‚·', func: layeredProxyConnect, priority: 3 }
            ];
            
            const promises = methods.map(async (method) => {
                try {
                    const result = await method.func(url);
                    return {
                        ...result,
                        methodName: method.name,
                        priority: method.priority
                    };
                } catch (error) {
                    return {
                        success: false,
                        methodName: method.name,
                        priority: method.priority,
                        error: error.message
                    };
                }
            });
            
            const results = await Promise.allSettled(promises);
            let bestResult = null;
            
            for (const result of results) {
                if (result.status === 'fulfilled' && result.value.success) {
                    if (!bestResult || result.value.priority < bestResult.priority) {
                        bestResult = result.value;
                    }
                    
                    // çµæœã‚’è¡¨ç¤º
                    addTestResult({
                        method: result.value.methodName,
                        success: true,
                        time: 0,
                        details: `âœ… ${result.value.methodName} åˆ©ç”¨å¯èƒ½`
                    });
                }
            }
            
            if (bestResult) {
                return bestResult;
            }
            
            // ã™ã¹ã¦å¤±æ•—ã—ãŸå ´åˆã¯è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            return await autoFallback(url);
        }
        
        // è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        async function autoFallback(url) {
            updateStatus('loading', 'è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œä¸­...');
            
            const fallbackMethods = [
                async () => {
                    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºèª
                    const cached = await checkLocalCache(url);
                    if (cached) return cached;
                    throw new Error('No cache');
                },
                async () => {
                    // ä»£æ›¿ãƒ—ãƒ­ã‚­ã‚·
                    return await tryAlternativeProxies(url);
                }
            ];
            
            for (const method of fallbackMethods) {
                try {
                    const result = await method();
                    if (result && result.success) {
                        addTestResult({
                            method: 'è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯',
                            success: true,
                            details: 'âœ… ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆåŠŸ'
                        });
                        return result;
                    }
                } catch (error) {
                    console.log('Fallback method failed:', error.message);
                }
            }
            
            addTestResult({
                method: 'è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯',
                success: false,
                details: 'âŒ ã™ã¹ã¦ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ–¹æ³•ãŒå¤±æ•—'
            });
            
            return {
                success: false,
                error: 'All fallback methods failed'
            };
        }
        
        // ã‚¯ã‚¤ãƒƒã‚¯ã‚¢ã‚¯ã‚»ã‚¹
        function quickAccess(url, method = 'smart') {
            mainSearch.value = url;
            startBrowse();
        }
        
        // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        function navigateFromBrowser() {
            const input = browserSearch.value.trim();
            if (!input) return;
            
            let url;
            if (input.includes('.') && !input.includes(' ')) {
                url = input.startsWith('http') ? input : 'https://' + input;
            } else {
                url = `https://www.google.com/search?q=${encodeURIComponent(input)}`;
            }
            
            smartConnect(url, currentMethodName);
            tabs[currentTab] = url;
        }
        
        // ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        function browserBack() {
            try {
                browserFrame.contentWindow.history.back();
            } catch (e) {
                console.log('Cannot go back');
            }
        }
        
        function browserForward() {
            try {
                browserFrame.contentWindow.history.forward();
            } catch (e) {
                console.log('Cannot go forward');
            }
        }
        
        function browserRefresh() {
            browserFrame.contentWindow.location.reload();
        }
        
        function browserHome() {
            smartConnect(tabs[currentTab], 'smart');
        }
        
        // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
        function switchTab(tabName) {
            currentTab = tabName;
            
            // UIæ›´æ–°
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ›´æ–°
            smartConnect(tabs[tabName], 'smart');
        }
        
        // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰
        function toggleGameMode() {
            gameMode = !gameMode;
            const btn = document.querySelector('.control-btn:nth-child(1)');
            
            if (gameMode) {
                btn.innerHTML = '<span>ğŸš«</span> Exit Game Mode';
                btn.style.background = 'linear-gradient(135deg, #ff416c, #ff4b2b)';
                document.body.style.cursor = 'none';
                
                // iframeå†…ã®ã‚²ãƒ¼ãƒ ã‚’æœ€é©åŒ–
                try {
                    const style = document.createElement('style');
                    style.textContent = `
                        * { cursor: none !important; }
                        body { overflow: hidden !important; }
                    `;
                    browserFrame.contentDocument.head.appendChild(style);
                } catch(e) {}
                
                showStatus('Game mode activated - Full screen optimized');
            } else {
                btn.innerHTML = '<span>ğŸ®</span> Game Mode';
                btn.style.background = 'linear-gradient(135deg, #8a2be2, #00d4ff)';
                document.body.style.cursor = 'default';
                
                showStatus('Game mode deactivated');
            }
        }
        
        // ãƒ†ã‚¹ãƒˆçµæœè¡¨ç¤º
        function toggleTestResults() {
            testResultsPanel.classList.toggle('active');
        }
        
        function clearTestResults() {
            document.getElementById('testResults').innerHTML = '';
        }
        
        function addTestResult(result) {
            const resultsDiv = document.getElementById('testResults');
            const resultDiv = document.createElement('div');
            
            resultDiv.className = `result-item ${result.success ? 'success' : 'error'}`;
            resultDiv.innerHTML = `
                <div class="result-icon">${result.success ? 'âœ…' : 'âŒ'}</div>
                <div class="result-details">
                    <strong>${result.method}</strong>
                    <div class="result-time">${result.details}${result.time ? ` (${result.time}ms)` : ''}</div>
                </div>
            `;
            
            resultsDiv.appendChild(resultDiv);
            
            // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ä¸€ç•ªä¸‹ã«
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }
        
        // å…¨æ‰‹æ³•ãƒ†ã‚¹ãƒˆ
        async function runAllMethods() {
            const url = browserSearch.value || mainSearch.value;
            if (!url || url.trim() === '') {
                alert('URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            clearTestResults();
            testResultsPanel.classList.add('active');
            
            const methods = [
                { name: 'ç›´æ¥æ¥ç¶š', func: directConnect },
                { name: 'ã‚¹ãƒ†ãƒ«ã‚¹ãƒ¢ãƒ¼ãƒ‰', func: stealthConnect },
                { name: 'å¤šå±¤ãƒ—ãƒ­ã‚­ã‚·', func: layeredProxyConnect }
            ];
            
            let successCount = 0;
            
            for (const method of methods) {
                addTestResult({
                    method: method.name,
                    success: false,
                    details: 'ğŸ”„ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œä¸­...'
                });
                
                try {
                    const startTime = Date.now();
                    const result = await method.func(url);
                    const time = Date.now() - startTime;
                    
                    if (result.success) {
                        successCount++;
                        addTestResult({
                            method: method.name,
                            success: true,
                            time: time,
                            details: `âœ… æ¥ç¶šæˆåŠŸ (${time}ms)`
                        });
                    } else {
                        addTestResult({
                            method: method.name,
                            success: false,
                            time: time,
                            details: `âŒ å¤±æ•—: ${result.error}`
                        });
                    }
                } catch (error) {
                    addTestResult({
                        method: method.name,
                        success: false,
                        details: `âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`
                    });
                }
                
                await delay(500);
            }
            
            // ã‚µãƒãƒªãƒ¼
            addTestResult({
                method: 'ãƒ†ã‚¹ãƒˆå®Œäº†',
                success: successCount === methods.length,
                details: `ğŸ“Š ${successCount}/${methods.length} æˆåŠŸ (${Math.round((successCount/methods.length)*100)}%)`
            });
        }
        
        // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function updateStatus(status, text = '') {
            connectionStatus.className = 'status-indicator ' + status;
            if (text) currentMethod.textContent = text;
            
            switch(status) {
                case 'idle':
                    connectionStatus.style.background = 'var(--text-dim)';
                    break;
                case 'loading':
                    connectionStatus.style.background = 'var(--warning)';
                    break;
                case 'success':
                    connectionStatus.style.background = 'var(--success)';
                    break;
                case 'error':
                    connectionStatus.style.background = 'var(--error)';
                    break;
            }
        }
        
        function getRandomUserAgent() {
            if (config.rotateUserAgent) {
                return userAgents[Math.floor(Math.random() * userAgents.length)];
            }
            return userAgents[0];
        }
        
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        async function fetchWithTimeout(url, options = {}, timeout = 10000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                throw error;
            }
        }
        
        function isValidResponse(data) {
            if (!data || data.trim() === '') return false;
            
            const errorIndicators = [
                'error', 'forbidden', 'blocked', 'access denied',
                'not allowed', 'restricted', 'firewall'
            ];
            
            const lowerData = data.toLowerCase();
            for (const indicator of errorIndicators) {
                if (lowerData.includes(indicator)) return false;
            }
            
            return true;
        }
        
        function handleFrameLoad() {
            try {
                const url = browserFrame.contentWindow.location.href;
                browserSearch.value = url;
                
                // ç›£è¦–ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®ç„¡åŠ¹åŒ–ã‚’è©¦ã¿ã‚‹
                disableMonitoringScripts();
            } catch(e) {
                // ã‚¯ãƒ­ã‚¹ã‚ªãƒªã‚¸ãƒ³åˆ¶é™
            }
        }
        
        function handleFrameError() {
            updateStatus('error', 'ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼');
        }
        
        function disableMonitoringScripts() {
            try {
                const iframeDoc = browserFrame.contentDocument;
                const scripts = iframeDoc.querySelectorAll('script');
                
                scripts.forEach(script => {
                    const src = script.src || '';
                    const content = script.textContent || '';
                    
                    // ç›£è¦–ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æ¤œå‡ºã—ã¦ç„¡åŠ¹åŒ–
                    if (src.includes('securly') || src.includes('content') || 
                        src.includes('blocked') || src.includes('monitoring') ||
                        content.includes('securly') || content.includes('monitoring')) {
                        script.remove();
                        console.log('Monitoring script disabled');
                    }
                });
            } catch(e) {
                // ã‚¯ãƒ­ã‚¹ã‚ªãƒªã‚¸ãƒ³åˆ¶é™
            }
        }
        
        function displayProxiedContent(data, originalUrl) {
            try {
                // iframeå†…ã«ç›´æ¥ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ›¸ãè¾¼ã‚€
                const iframeDoc = browserFrame.contentDocument;
                iframeDoc.open();
                iframeDoc.write(data);
                iframeDoc.close();
                
                // å…ƒã®URLã‚’è¨­å®šï¼ˆè¡¨ç¤ºç”¨ï¼‰
                browserSearch.value = originalUrl;
            } catch(e) {
                console.log('Cannot display proxied content:', e.message);
            }
        }
        
        // ãã®ä»–ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        async function emulateWebSocketFetch(url) {
            // WebSocketã‚¨ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ç°¡æ˜“å®Ÿè£…
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject(new Error('WebSocket emulation not configured'));
                }, 1000);
            });
        }
        
        async function checkLocalCache(url) {
            // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯ã®ç°¡æ˜“å®Ÿè£…
            return null;
        }
        
        async function tryAlternativeProxies(url) {
            // ä»£æ›¿ãƒ—ãƒ­ã‚­ã‚·ã®è©¦è¡Œ
            const altProxies = [
                'https://api.codetabs.com/v1/proxy/?quest=',
                'https://corsproxy.io/?'
            ];
            
            for (const proxy of altProxies) {
                try {
                    const response = await fetchWithTimeout(proxy + encodeURIComponent(url), {}, 5000);
                    if (response.ok) {
                        const data = await response.text();
                        return {
                            success: true,
                            data: data,
                            method: 'ä»£æ›¿ãƒ—ãƒ­ã‚­ã‚·',
                            anonymity: 'ä¸­'
                        };
                    }
                } catch (error) {
                    console.log('Alternative proxy failed:', error.message);
                }
            }
            
            return null;
        }
        
        function showStatus(message) {
            updateStatus('loading', message);
            setTimeout(() => updateStatus('success', 'æº–å‚™å®Œäº†'), 2000);
        }
        
        // åˆæœŸåŒ–å®Ÿè¡Œ
        window.onload = init;
        
        // Enterã‚­ãƒ¼ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                runAllMethods();
            }
            if (e.key === 'Escape') {
                testResultsPanel.classList.remove('active');
            }
        });
    </script>
</body>
</html>
